# 로그인 프로세스

## 개요

1DD는 Supabase Auth를 사용하여 사용자 인증을 처리합니다. 현재 Google OAuth 로그인을 지원하며, 이메일/비밀번호 로그인은 부분적으로 구현되어 있습니다.

## 인증 흐름도

```
사용자
  ↓
[회원가입/로그인 모달]
  ↓
[Google OAuth 시작]
  ↓
[Supabase Auth]
  ↓
[Google 인증 완료]
  ↓
[/auth/callback]
  ↓
[exchangeCodeForSession]
  ↓
[v1_upsert_user 호출]
  ↓
[DB 저장 (odd.tbl_users)]
  ↓
[UserStore 업데이트]
  ↓
[/profile/{username} 리다이렉트]
```

## 1. Google OAuth 로그인

### 1.1 시작점

**파일**: `src/pages/auth/SignUpModal.tsx`

```typescript
// Google 로그인 버튼 클릭 시
await supabase.auth.signInWithOAuth({
  provider: "google",
  options: {
    redirectTo: `${window.location.origin}/auth/callback`,
  },
});
```

### 1.2 OAuth 흐름

1. **사용자 클릭**: "Google로 계속하기" 버튼 클릭
2. **Supabase 리다이렉트**: Google OAuth 페이지로 이동
3. **Google 인증**: 사용자가 Google 계정으로 로그인
4. **콜백**: `{origin}/auth/callback?code=xxx` 로 리다이렉트

## 2. 인증 콜백 처리

### 2.1 콜백 페이지

**파일**: `src/pages/auth/AuthCallbackPage.tsx`

**주요 단계**:

1. **URL 파라미터 확인**
   ```typescript
   const code = urlParams.get("code");
   const errorParam = urlParams.get("error");
   const debugMode = urlParams.get("debug") === "true";
   ```

2. **Code를 세션으로 교환**
   ```typescript
   const { data, error } = await supabase.auth.exchangeCodeForSession(code);
   ```

3. **DB에 사용자 저장**
   ```typescript
   const { data: dbUser } = await supabase
     .schema("odd")
     .rpc("v1_upsert_user", {
       p_auth_id: authUser.id,
       p_email: authUser.email,
       p_display_name: authUser.user_metadata?.full_name || null,
       p_avatar_url: authUser.user_metadata?.avatar_url || null,
     });
   ```

4. **UserStore 업데이트**
   ```typescript
   login({
     id: savedUser.id.toString(),
     username: savedUser.username || "",
     displayName: savedUser.display_name || "",
     // ... 기타 필드
   });
   ```

5. **프로필 페이지로 리다이렉트**
   ```typescript
   navigate(`/profile/${savedUser.username}`, { replace: true });
   ```

### 2.2 username 자동 생성

**DB 함수**: `odd.v1_upsert_user`

username은 자동으로 생성되며, 형식은 `user_{8자리}`입니다.

**생성 규칙**:
- 1차 시도: `user_` + auth_id 앞 8자리 (예: `user_89bf5abb`)
- 2차 시도: `user_` + auth_id 앞 4자리 + 뒤 4자리
- 3차 시도: `user_` + auth_id 중간 8자리
- 4차 시도: `user_` + auth_id 뒤쪽 8자리
- 5차~: `user_` + auth_id 앞 4자리 + 랜덤 4자리

충돌 시 다음 후보로 자동 재시도합니다.

## 3. 사용자 스토어 (UserStore)

### 3.1 스토어 구조

**파일**: `src/entities/user/model/user.store.ts`

**상태**:
- `user`: 현재 로그인한 사용자 정보
- `isAuthenticated`: 인증 여부
- `sessionToken`: JWT 토큰 (현재는 데모용)
- `isLoading`: 로딩 상태

### 3.2 주요 메서드

#### `login(user: User)`
- 사용자 정보를 스토어에 저장
- 인증 상태를 `true`로 설정
- JWT 토큰 생성 (현재는 데모용)

#### `logout()`
- 사용자 정보 초기화
- 인증 상태를 `false`로 설정

#### `updateUser(updates: Partial<User>)`
- 현재 사용자 정보 부분 업데이트

#### `addPoints(points: number)`
- 사용자 포인트 추가

### 3.3 영속화

Zustand의 `persist` 미들웨어를 사용하여 `localStorage`에 저장됩니다.

**키**: `user-storage`

## 4. DB 스키마

### 4.1 테이블: `odd.tbl_users`

| 컬럼명                      | 타입         | 설명                |
|----------------------------|--------------|---------------------|
| id                         | bigint       | PK, 자동 증가        |
| auth_id                    | uuid         | Supabase Auth ID (UNIQUE) |
| email                      | text         | 이메일 (UNIQUE)      |
| username                   | text         | @username (UNIQUE)  |
| display_name               | text         | 표시 이름            |
| avatar_url                 | text         | 프로필 이미지 URL    |
| bio                        | text         | 자기소개             |
| points                     | integer      | 포인트 (기본값: 0)   |
| level                      | text         | bronze/silver/gold/platinum/diamond |
| subscribed_projects_count | integer      | 구독한 프로젝트 수   |
| supported_projects_count   | integer      | 후원한 프로젝트 수   |
| projects_count             | integer      | 내 프로젝트 수       |
| is_active                  | boolean      | 활성 상태            |
| created_at                 | timestamptz  | 생성일시             |
| updated_at                 | timestamptz  | 수정일시             |

### 4.2 함수: `odd.v1_upsert_user`

**목적**: OAuth 로그인 시 사용자 정보 저장/업데이트

**매개변수**:
- `p_auth_id`: Supabase Auth의 user.id (UUID)
- `p_email`: 사용자 이메일
- `p_display_name`: 표시 이름 (Google의 full_name)
- `p_avatar_url`: 프로필 이미지 URL

**동작**:
- 기존 사용자 (auth_id 존재): UPDATE 수행
- 신규 사용자: INSERT 수행 (username 자동 생성)

**반환값**: 저장된 사용자 레코드

## 5. 이메일/비밀번호 로그인 (미완성)

### 5.1 현재 상태

**파일**: `src/pages/auth/LoginPage.tsx`

현재는 Supabase Auth의 `signInWithPassword`를 호출하지만, DB에서 사용자 정보를 조회하지 않고 데모 데이터를 사용합니다.

**TODO**:
- 로그인 성공 후 `v1_get_user_by_auth_id` 호출
- DB에서 사용자 정보 조회
- UserStore 업데이트

## 6. 에러 처리

### 6.1 OAuth 에러

콜백 URL에 `error` 파라미터가 있으면 에러 메시지를 표시합니다.

```typescript
if (errorParam) {
  setError(`${errorParam}: ${errorDescription}`);
  return;
}
```

### 6.2 DB 저장 에러

`v1_upsert_user` 호출 실패 시 에러 메시지를 표시하고 홈으로 이동할 수 있는 버튼을 제공합니다.

## 7. 디버그 모드

콜백 URL에 `?debug=true` 파라미터를 추가하면:
- 프로필 페이지로 자동 리다이렉트하지 않음
- 에러 정보를 화면에 표시
- 디버깅 정보 확인 가능

**예시**: `/auth/callback?code=xxx&debug=true`

## 8. 보안 고려사항

### 8.1 RLS (Row Level Security)

`odd.tbl_users` 테이블에 RLS가 활성화되어 있습니다:

- **SELECT**: 모든 인증된 사용자가 조회 가능
- **UPDATE**: 자신의 데이터만 수정 가능 (`auth_id = auth.uid()`)
- **INSERT**: 자신의 프로필만 생성 가능 (`auth_id = auth.uid()`)

### 8.2 API 키

- **Publishable Key**: 클라이언트에서 사용 (노출 가능)
- **Secret Key**: 서버에서만 사용 (절대 노출 금지)

## 9. 테스트 시나리오

### 9.1 신규 사용자 가입

1. 회원가입 모달 열기
2. "Google로 계속하기" 클릭
3. Google 계정 선택
4. `/auth/callback`으로 리다이렉트
5. DB에 사용자 저장 (`user_xxxxxxxx` 형식)
6. `/profile/user_xxxxxxxx`로 리다이렉트

### 9.2 기존 사용자 로그인

1. 회원가입 모달 열기
2. "Google로 계속하기" 클릭
3. Google 계정 선택
4. `/auth/callback`으로 리다이렉트
5. DB에서 기존 사용자 업데이트
6. `/profile/{username}`로 리다이렉트

## 10. 관련 파일

- `src/pages/auth/SignUpModal.tsx` - 회원가입 모달 (Google OAuth 시작)
- `src/pages/auth/AuthCallbackPage.tsx` - 인증 콜백 처리
- `src/pages/auth/LoginPage.tsx` - 로그인 페이지 (미완성)
- `src/entities/user/model/user.store.ts` - 사용자 스토어
- `src/shared/lib/supabase.ts` - Supabase 클라이언트 설정

## 11. 향후 개선 사항

- [ ] 이메일/비밀번호 로그인 완전 구현
- [ ] 비밀번호 재설정 기능
- [ ] 세션 만료 처리
- [ ] 자동 로그인 (refresh token)
- [ ] 소셜 로그인 추가 (GitHub, Twitter 등)
- [ ] username 변경 기능 UI 구현
- [ ] 프로필 편집 기능 DB 연동

